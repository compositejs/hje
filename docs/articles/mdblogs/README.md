# MdBlogs

一套使用 Markdown 文件组成的博客和知识库前端应用，特别适用于纯静态前端部署。

## 安装

目前，本库作为 Hyper-JSON Engine 的示例子前端库的形式存在，并无独立前端包。

### NPM

```bash
npm i hje
```

首先，需要在本地安装 Hyper-JSON Engine 包，然后可以在其 `hje/dist/mdblogs` 引入所有相关业务能力。

```typescript
import { * as Hje } from "hje";
import { render as renderMdBlogs } from "hje/dist/mdblogs";

const ele = Hje.appendElement(null);
renderMdBlogs(ele, "./config.json", { title: true });
```

### 直接引入JS文件

如果不是使用 NPM 进行包管理，而是希望直接在 HTML 中引入静态文件，那么可以将以下任意一个已打包好的文件，直接进行引用，或下载至本地后再进行引用。但请注意，使用本方法引入，请一定要先引入其所依赖的 Hyper-JSON Engine 库，详见相关文档。

- `https://cdn.jsdelivr.net/npm/hje/dist/mdblogs.js`
- `https://unpkg.com/hje/dist/mdblogs.js`

然后，就可以通过 `DeepX.MdBlogs` 命名空间进行访问。

```typescript
const ele = Hje.appendElement(null);
DeepX.MdBlogs.render(ele, "./config.json", { title: true });
```

### 依赖

- MdBlogs 依赖 Hyper-JSON Engine，需自行引用。
- 在执行 Markdown 渲染时，需要引用并适配对应的渲染函数，通过暴露的 `hooks`，设置其 `renderMd` 回调，其两个入参以此为目标 DOM 和 Markdown 文本，回调无需返回值。

## 工作模式

MdBlogs 内部内使用 Hyper-JSON Engine 作为渲染引擎。其汇总并路由至对应 Markdown 文件，以此作为页面渲染的内容主体。

### 静态文件索引

由于整套机制并不依托于服务端，而完全基于 HTTPS 路径访问的方式来读取对应 Markdown 文件，因此，这意味着本库不具备自动遍历所有文件的能力。为此，需要有一个配置和索引的存储库，来提供基础的信息服务能力。但考虑到本库不假设有后端数据库或缓存的服务的存在，该信息服务允许是基于纯 JSON 静态文件进行部署的，而后由本库内部自行解析和处理，以实现遍历和读取。出于使用时尽可能简化复杂度的考虑，该静态文件仅需一份。

因此，除了博客和知识库中各篇基于 Markdown 格式的文档外，还需要有一个 JSON 文件作为统一配置文件，可不属于 CDN 之上。通常，这个 JSON 文件会放置于这套博客或知识库所在根目录中。

### 呈现与路由

当最终用户从浏览器访问时，访问该 HTML 时将呈现首页，内含知识库和博客目录。点击一项后，页面地址会变更，增加 `?` 及后面一串路由地址，同时页面主体区域呈现选中的文档。

## 快速搭建

只需将 Markdown 文件及内附的图片，按照约定的文件目录结构放置，并将信息填入至配置中，便可完成搭建。

假设需要同时支持博客和知识库：其中，博客有3篇，包括2024年一篇和2025年两篇；知识库也是3篇。

### 文件目录结构

所有的文章需要放置在目录中，建议为每一篇文章创建文件夹，并将内附图片也放置于对应文件夹或子文件夹内。

不过请特别注意，博客文章需要在外层还有一级目录，且该级目录需要是以博客发布的年份来命名。也就是说，示例中的场景，至少需要两个文件夹，分别名为 `2024` 和 `2025`。知识库则无此要求。下方是依据示例所建立的文件夹结构。

```
- 2024
  - blog-a
    - README.md
- 2025
  - blog-b
    - README.md
  - blog-c
    - article.md
- intro
  - README.md
- tools
  - cli.md
  - gui.md
- config.json (配置文件)
```

以上示例不同文章采用了不同的目录存放形态，这些形态都是受支持的。

- 博客 A 和 B 均放置于对应年份目录下自己的目录中，且主体文章的文件命名为 `README.md`，这个名字是 Markdown 目录结构中经典的目录介绍文件名；
- 而博客 C 则使用了自定义文件名 `article.md`；
- 同样的，知识库文章《介绍》被放置于自身独立目录 `intro` 中，且命名为经典的 `README.md`；
- 于此同时，另外两篇知识库文章则放置于同一个目录 `tools` 中，并分别有不同的文件名 `cli.md` 和 `gui.md`。

### 配置文件填写

在 `config.json` 中，配置以下内容，将这些文章引入进来，并添加更多附加信息。其中，

- 博客均放置于 `blog` 字段中，该字段是个数组，里面元素均为对象，通过配置 `name` 为文章名、`dir` 为目录名（不含年份）、`file` 为文件名（如果为 `README.md` 可简写为布尔值 true）、`date` 为发布日期（采用 `YYYYMMDD` 格式），另外还可以有作者姓名 `author`、关键词 `keywords`、简介 `intro` 等可选字段。博客文章按照从早到新顺序排列，展示时会自动以此进行倒序。
- 知识库文章放置于 `docs` 字段中，结构与博客的类似，不过其内元素 `date` 不再为必选而是可选，以及 `dir` 目录需要是完整的相对路径。另外，知识库文章支持树形结构，通过在需要设置子文章的文章结构中，新增 `children` 字段，值为数组，放置各子文章对象结构。

```json
{
  "name": "示例站点",
  "blog": [
    {
      "name": "博客 A",
      "date": "20241020",
      "dir": "blog-a",
      "file": true
    }, {
      "name": "博客 B",
      "date": "20250201",
      "dir": "blog-b",
      "file": true
    }, {
      "name": "博客 C",
      "date": "20250201",
      "dir": "blog-c",
      "file": "article.md"
    }
  ],
  "docs": [
    {
      "name": "介绍",
      "dir": "intro",
      "file": true
    }, {
      "name": "CLI",
      "dir": "tools",
      "file": "cli.md"
    }, {
      "name": "GUI",
      "dir": "tools",
      "file": "gui.md"
    }
  ]
}
```

### 目录呈现

- 介绍
- CLI
- GUI

> 2025

- 博客 C
- 博客 B

> 2024

- 博客 A

### 页面路由映射

文件名会影响最终的页面路由，以上示例最终会被映射为如下。

| 文章 | URL 参数 | 指向文件路径 |
| -------- | ------------------ | -------------------- |
| 博客 A | `?2024/blog-a` | `/2024/blog-a/README.md` |
| 博客 B | `?2025/blog-b` | `/2025/blog-b/README.md` |
| 博客 C | `?2025/blog-c/article` | `/2025/blog-c/article.md` |
| 介绍 | `?intro` | `/intro/README.md` |
| CLI | `?tools/cli` | `/tools/cli.md` |
| GUI | `?tools/gui` | `/tools/gui.md` |

## 配置文件说明

配置文件采用 JSON 格式，其描述了该博客或知识库的基本信息，以及罗列了所有文档。

### 概述

为 `IArticleCollection` 类型。

以下可作为实际案例的参考，

| 类型 | 案例 | 配置文件地址 |
| ------ | ------------ | ---------------------- |
| 博客 | [Kingcean 前端博客](https://kingcean.org/blog/) | `https://kingcean.org/blog/config.json` |
| 知识库 | [DataSense 库介绍](https://datasense.js.org/articles) | `https://datasense.js.org/articles/config.json` |

配置文件的 JSON 各属性如下。

> https://github.com/compositejs/hje/dist/mdblogs.schema.json

- `name` _字符串 \*_ 🌐：站点名称。
- `description` _字符串 \*_ 🌐：站点描述。
- `home` _字符串_ 🌐：Markdown 文档相对地址，首页要呈现的内容。
- `blog` _对象数组 或 对象_：博客配置信息。如果是对象数组，那么数组里面的内容即为该博客中各文档的文档信息（`IArticleInfo`）；如果是对象，那么为博客的详细配置信息，其主要结构如下。
  - `list` _对象数组 *_：博客文档列表。数组中的各项为文档信息（`IArticleInfo`），按发布时间顺序升序（从早到近）排列。
  - `dir` _字符串_：所有博客文档所在根目录的相对路径。本字段仅供博客内容并非位于本配置文件所在路径（包括位于其内子路径）时所用。
  - `reverse` _布尔值_：指示字段 `list` 是否为反转，即其实际内容为按时间顺序降序（从近到早）排列。默认为 `false`。
- `docs` _对象数组_：知识库文档列表。支持通过数组元素内 `children` 字段形成树形结构，但建议层级不要超过3层。数组中的各项为文档信息（`IArticleInfo`）；数组中也可包含分组标签。
- `hiddenArticles` _对象数组_：隐藏文档列表，默认不会现实在目录中。数组中的各项为文档信息（`IArticleInfo`）。
- `redir` _对象_：别名路由，其中 key 为预期的路径路由，value 为跳转到的路径路由。
- `options` _对象_：其它配置信息。
  - `disableName` _布尔值_：首页不显示站点名称和描述。
  - `disableMenu` _布尔值_：指示是否禁用文章内目录。
  - `disableAuthors` _布尔值_：指示是否不显示贡献者信息及发布日期。
- `$defs` _对象_：引用资源。
  - `keywords` _对象数组_：关键词的本地化翻译列表。其数组元素均为对象，这些对象可以包含以下字段。
    - `value` _字符串 \*_：关键词的标识符或 ID。
    - `name` _字符串_ 🌐：关键词的显示名称。
  - `roles` _对象数组_：角色名称的本地化翻译列表。其数组元素均为对象，这些对象可以包含以下字段。
    - `value` _字符串 \*_：关键词的标识符或 ID。
    - `name` _字符串_ 🌐：关键词的显示名称。
  - `contributors` _对象数组_：所有的文章贡献者（如作者）列表。其数组元素均为对象，这些对象可以包含以下字段。
    - `name` _字符串 \*_：贡献者的姓名或显示名称。
    - `email` _字符串_：贡献者的电子邮箱地址。
    - `url` _字符串_：贡献者的个人首页。
    - `avatar` _字符串_：贡献者的头像地址。
  - 其它预计被引用的信息。

注：

- 字段名后类型旁带有 \* 星号的为必填项，其余均为可选。
- 字段名后烈性旁带有 🌐 地球的，表示该字段支持语言扩展，即还可有另一或多个字段，其名称也是该字段的名称，但后面多一个 `#` 号，连同一个 ISO 639-1 的语言标识符。例如，字段 `name` 假设支持语言扩展，那么还可以同层级有个字段名为 `name#zh` 以及另一个 `name#fr`，此时如果是中文环境，则在读取 `name` 字段时返回 `name#zh` 的值，而法语环境则返回 `name#fr` 的值，其它环境（例如英语环境）则返回 `name` 的值。
- 下同。

在一个站点内，允许博客和知识库同时存在，此时在文章列表菜单中，会优先显示知识库列表，再显示博客列表。

### 文档信息

博客、知识库、隐藏文档列表中，各项的文档信息，均为对象格式，为 `IArticleInfo` 类型，其属性如下。

- `id` _字符串_：唯一标识，需为 UUID 或 GUID。虽然是唯一标识，但通常可以不需要。
- `name` _字符串 \*_ 🌐：文章的显示名称。
- `disable` _布尔值_：指示是否下线该文章。当为 `true` 时，文章不被展现，也不会被指向。
- `subtitle` _字符串_ 🌐：副标题，会以较弱样式显示于标题旁。
- `intro` _字符串_ 🌐：简介。仅出现于首页目录的，各文章链接的 Tooltips 中，或根据定制在目录中呈现。
- `date` _字符串_：文章发布的日期，需以 `YYYYMMDD` 格式，共8个字符，其内没有空格、短横线、斜线、反斜线。该字段对于博客内容为必填项，其余为选填。
- `thumb` _字符串_：缩略图 URL。
- `dir` _字符串_ 🌐：Markdown 文档所在目录路径，相对于本配置文件的相对 URL 地址，路径前后无需斜线或反斜线。
  - 对于博客，所有 Markdown 文件均需首先放置于以该文章发布日期的年份命名的文件夹中，但本字段中无需包含年份。例如，前面示例中 `/2025/blog-c/article.md` 需要配置为字符串 `blog-c`，另，`date` 字段中前4个字符（`YYYY`）必须为 `2025`，即该文章需发布于 2025 年。
  - 对于知识库和隐藏文档列表，则该路径需要包含完整目录路径。例如，前面示例中 `/tools/cli.md` 需要配置为字符串 `tools`。
- `file` _字符串 或 布尔值 \*_ 🌐：Markdown 文件名（含扩展名）。当文件名为 `README.md` 时，此字段可设为布尔值 `true` 以简化书写；当仅访问路径而无文件名时亦能获取到该 Markdown 格式内容时，可设为布尔值 `false`。例如，前面示例中 `/tools/cli.md` 需要配置为字符串 `cli.md`，而 `/2025/blog-b/README.md` 则可配置为字符串 `README.md` 或布尔值 `true`。
- `keywords` _字符串数组_：关键词列表。该列表中的项，可以是本配置文件中 `$defs.keywords` 字段下，各数组中其中一项的 `value` 值，此时会自动读取其尽可能适用于本地语言的 `name` 值进行呈现。
- `author`
  - _字符串_：当只有一个作者时，可以为字符串，此时内容即为作者的姓名或显示名，如果配置文件 `$defs.contributors` 字段中包含了该作者，则会自动关联。
  - _字符串数组_：各项字符串的内容即为作者的姓名或显示名，如果配置文件 `$defs.contributors` 字段中包含了该作者，则会自动关联。
  - _对象_：可以按角色分别指定对应的贡献者列表。其中 key 为角色名，如果配置文件 `$defs.roles` 字段下，各数组中其中一项的 `value` 值与之相等，则会自动关联；如果配置文件 `$defs.contributors` 字段中包含了该作者，则会自动关联。
- `location` _字符串_：文章发布时所在城市。仅当需要显示表达此信息时，才需要填写。
- `related` _对象列表_：相关参考资料的链接列表。数组中的各项为对象，具体字段如下；数组中也可包含分组标签。
  - `name` _字符串 \*_ 🌐：链接的显示标题。
  - `url` _字符串 \*_ 🌐：链接 URL。
  - `subtitle` _字符串_ 🌐：链接的子标题，会以较弱的样式呈现于显示标题旁。
  - `data` _对象_：额外的数据，用于编程时访问。
- `end` _布尔值 或 字符串 或 对象_：截断标识。如果 Markdown 中包含的内容，仅需呈现其前部或中间部内容，可用此标识进行控制。
- `notes` _字符串数组_ 🌐：文章呈现的结尾处，支持配置一些小字进行声明，本字段中数组每一项将作为一行进行呈现。
- `children` _对象数组_：子文章列表。数组中各项为文档信息（`IArticleInfo`）。
  - 对于博客，本字段仅第一层级博客内容允许存在，其根深文档结构不再支持本字段。同时，相关子内容不会在目录中呈现，而只能通过外部链接或文章的相关参考链接进行访问。
  - 对于知识库，支持多层级，并以此构建树状文档结构，但不建议超过3层。
  - 对于隐藏文章列表，本字段仅第一层级博客内容允许存在，其根深文档结构不再支持本字段。同时，相关子内容也不会在目录中呈现，而只能通过外部链接或文章的相关参考链接进行访问。
- `data` _对象_：用于编程控制时读取。
- `options` _对象_：其它控制能力。
  - `disableMenu` _布尔值_：指示是否禁用文章内目录。
  - `disableAuthors` _布尔值_：指示是否不显示贡献者信息及发布日期。
  - `banner` _字符串 或 对象_：题图。用于文章显示时，在标题的上部显示的额外图片。当为字符串时，内容即为图片的 URL；当为对象时，其字段如下。
    - `name` _字符串_：图片说明。
    - `url` _字符串 \*_：图片 URL。
    - `maxHeight` _整数_：图片呈现时的最大高度。
    - `cover` _布尔值_：图片是否横向拉伸，并在有 `maxHeight` 设置并实际高度超过时执行裁剪；否则，自适应等比缩放。
  - `kind` _字符串数组_：用于编程筛选时用的关键词。

### 文章截断标识

对于文档信息（`IArticleInfo`）中的 `end` 字段，可以用于控制在 Markdown 内容输出时，是否进行特定的截断处理。这种场景通常出现于，Markdown 文件本身包含了完整信息，然而这些信息在渲染时，有些其实不想输出。

- 如果 `end` 不存在，或设置为布尔值 `false` 时，则不会进行截断处理。
- 通过设置 `end` 字段为布尔值 `true` 时，会在 Markdown 源文件中寻找 `<!-- End -->\n` 字符串，该字符串及后续内容会不予输出。其中这里的 `\n` 表示换行通配符。
- 通过设置 `end` 字段为字符串时，假设为 `abcd`，会在 Markdown 源文件中寻找 `<!-- abcd -->\n` 字符串，该字符串及后续内容会不予输出。其中这里的 `\n` 表示换行通配符。
- 通过设置 `end` 字段为对象时，其支持以下属性。
  - `start` _布尔值 或 字符串_：起始点，此位置及以上不会被输出。该值类似于 `end` 为布尔值或字符串时，不过为布尔值时，找寻的时 `\n<!-- Start -->`，且不输出的是该字符串及前面内容；当为字符串时，情形类似。其中这里的 `\n` 表示换行通配符。
  - `end` _布尔值 或 字符串_：结束点，此位置及以下不会被输出。等同于 `end` 为布尔值或字符串时。
  - `urls` _对象数组_：替换 Markdown 中的链接地址。其数组元素均为对象，这些对象可以包含以下字段。
    - `old` _字符串_：原链接地址，用于被替换，大小写敏感。
    - `by` _字符串_：新链接地址。

例如，当 `end` 设置为 `true` 时，有以下 Markdown 文档。

```markdown
简介：这是一篇关于26个英文字母的文章。
<!-- 这里是文章开始 -->

ABCDEFG
HIJKLMN
OPQ RST
UVW XYZ

<!-- End -->
【注】以上字母均是大写。
```

此时会去除其中 `<!-- End -->\n` 及以下内容，于是只展现以下部分。

```markdown
简介：这是一篇关于26个英文字母的文章。
<!-- 这里是文章开始 -->

ABCDEFG
HIJKLMN
OPQ RST
UVW XYZ

```

如果设置 `end` 为以下结构体。

```json
{
  "start": "这里是文章开始",
  "end": true
}
```

那么得到的结果如下。

```markdown

ABCDEFG
HIJKLMN
OPQ RST
UVW XYZ

```

### 分组标签

配置文件中的 `docs` 字段（知识库列表），及各文档信息（`IArticleInfo`）中的 `related` 字段（相关参考链接），除了对应类型对象外，还可以包含分组标签，用于将这些信息进行分组。其结构如下。

- `name` _字符串_ 🌐：标签显示名。
- `disable` _固定字符串_：固定为字符串 `label` 或字符串 `header`。

另请注意，

- 文档信息（`IArticleInfo`）的子文档（即 `children` 字段）不支持插入此类型；
- 分组标签也可以不以对象形式存在，而是以字符串形式，此时该字符串即成为标签显示名，但不支持多语言情形；
- 当有多个连续分组标签时，仅最后一个会被显示，前面的会被过滤；如果数组最后一项为分组标签，即其后没有其它内容，也会被过滤。

## 程序控制

同通过 Type Script 编程来渲染或获取指定配置文件所描述的博客或知识库信息。

### 获取完整结构体

函数 `fetchArticles` 可用于获取完整结构体，返回的是 `Promise`，里面是 `Articles` 类型对象，其内可继续通过相关属性或方法来获取具体信息。

### 直接渲染

可以通过 Hyper-JSON Engine 控件 `ArticlesPart` 来执行渲染，其描述结构中的 `data` 字段为 `IArticlesPartData` 类型，通过其中 `articles` 字段接受配置文件的 URL 地址或 `Articles` 对象。

或者，函数 `render` 用于在指定 DOM 上渲染该博客或知识库前端组件，并托管页面路由。

### 仅渲染目录

函数 `generateMenu` 或 `generateMenuPromise` 可以用于仅渲染目录，并通过传参可进一步进行过滤和控制具体渲染。
